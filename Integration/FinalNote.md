# OperatingSystem Note

## 9장.Virtual Memory

버츄얼 메모리, 가상 메모리는 물리적 메모리의 한계를 극복하기 위해 나온 개념이다.

프로세스를 실행할 때 실행에 필요한 일부분만 메모리에 로드하고 나머지는 디스크에 두는 것이다.

현재 필요한 page만 메모리에 올리는 것을 Demand Paging이라고 한다. 

### Demand Paging

Demand paging은 실제로 필요할 때 page를 메모리에 올리는 것이다. 

이를 통해 CPU 이용률과 처리율이 높아지고, 더 많은 사용자를 수용할 수 있다.  

## 10장. File System

파일은 논리적 저장단위로 관련된 정보 자료들의 집합에 이름을 붙인 것이다.

컴퓨터 시스템의 편리한 사용을 위해 정보 저장의 일괄된 논리적 관점을 제공한다.  

일반적으로 레코드(Record) 혹은 블록(Block) 단위로 비휘발성 보조기억장치에 저장된다.  

파일 속성(File attribute) 또는 파일의 메타데이터(metadata)는 파일을 관리하기 위한 각종 정보들이다. 파일 자체의 내용은 아니다. 

파일 이름, 유형, 저장된 위치, 파일 사이즈, 접근 권한, 소유자, 시간(생성/변경/사용) 등 파일에 대한 전반적인 정보를 말한다. 

파일 시스템(File System)은 운영체제와 모든 데이터, 프로그램의 저장과 접근을 위한 기법을 제공한다.

시스템 내의 모든 파일에 관한 정보를 제공하는 계층적 디렉터리 구조이고, 파일 및 파일의 메타데이터, 디렉터리 정보 등을 관리한다.

파티션(Partition)은 연속된 저장 공간을 하나 이상의 연속되고 독립적인 영역으로 나누어 사용할 수 있도록 정의한 규약이다. 하나의 물리적 디스크 안에 여러 파티션을 두는 게 일반적이지만, 여러 물리적 디스크를 하나의 파티션으로 구성하기도 한다. 

*다시 정리*
## 13장. File System Interface

- 파일은 운영체제의 의하여 정의되고 구현되는 추상적인 자료형이다.
- 파일은 논리 레코드의 연속으로서, 바이트, 행 또는 좀 더 복잡한 자료 항목들이다.
- 운영체제는 다양한 레코드형을 사용자에게 제공하거나 아니면 사용자가 프로그램상으로 정의하도록 해준다.
- 운영체제의 가장 중요한 문제는 논리적인 파일을 실제 저장장치(하드)에 어떻게 매핑시키는 것인지
  - 보통 물리 레코드 크기는 논리 레코드와 일치하지 않기 때문에, 논리 레코드를 물리 레코드에 연관시켜야한다.
  - 이 작업은 운영체제에 의하여 제공되거나 사용자의 응용 프로그램에서 할 수 있다.
- 파일 시스템 내에서 파일을 구조화하는 디렉터리를 만드는 것이 유용하다.
  - 다중 사용자 시스템에서 1단계 디렉터리는 모든 파일이 고유의 이름을 가져야 하므로 파일 명칭 부여 문제를 유발한다.
  - 2단게 디렉터리는 각 사용자에 대하여 독자적인 디렉터리를 할당함으로써 이 문제를 해결한다.
  - 디렉터리는 이름으로 파일을 기록하고, 디스크 상에서의 파일의 위치, 길이, 형태, 소유자, 생성시간, 마지막 사용 시간등 과 같은 정보를 포함한다.
- 파일 또한 디스크의 공간을 회수하기 위해 가비지 컬랙션이 필요
  - 2단계 디렉터리를 일반화하여 확장하면 트리 구조 디렉터리가 되는데 사용자만의 서브디렉터리를 구성할 수 있게 해준다.
  - 일반적인 그래프 디렉터리는 디렉터리와 파일의 공유에 완전한 융통성을 주는 대신 사용되지 않는 디스크 공간을 회수하기 위해 가비지 컬랙션을 필요로 한다.

### Contiguous Allocation (연속 할당)

하나의 파일이 디스크 상에 연속해서 저장되는 방식

- 단점
  - 외부 조각이 발생한다.
  - 파일의 크기를 키우는 데 제약이 있다. 파일을 수정하면서 파일의 크기가 커질 수 있는데, 그것에 제약이 있다는 것이다. 그래서 미리 여유 공간을 할당할 수는 있지만, 이 경우 내부 조각이 발생할 수 있다.

- 장점
  - 빠른 입출력이 가능하다.
  - 한번의 seek/rotation으로 많은 바이트를 전송할 수 있다.
  - realtime file용으로, 또는 이미 run 중이던 프로세스의 swapping용으로 사용 가능하다.
  - 직접 접근(임의 접근)이 가능하다.

### Linked Allocation (연결 할당)

파일의 데이터를 디스크에 연속적으로 배치하는 대신, 빈 위치 아무데나 들어갈 수 있게 배치하는 방식

- 장점
  - 외부 조각이 발생하지 않는다.
- 단점
  - 직접 접근(임의 접근)이 불가능하다.
  - reliability 문제
  - 하나의 sector가 bad sector가 되어 pointer가 유실되면 이후 부분을 모두 잃어버리게 된다.
  - 포인터를 위한 공간이 block의 일부가 되어 공간 효율성을 떨어뜨린다.
  - 디스크에서 하나의 sector는 512byte를 차지하는데, 포인터가 4byte를 차지하므로 비효율적이다.
- 변형
  - File-allocation table (FAT) 파일 시스템
  - 포인터를 별도의 위치에 보관하여 reliability와 공간 효율성의 문제를 해결한다. (아래에서 자세히 다룸)

### Indexed Allocation (인덱스 할당)

블록 하나에 위치 정보를 저장하는데, 이 블록을 인덱스 블록이라고 한다. 디렉토리는 파일의 위치 정보 대신 인덱스 블록 값을 저장한다.

- 장점
  - 외부 조각이 발생하지 않는다.
  - 직접 접근(임의 접근)이 가능하다.
  - (연속 할당 / 연결 할당의 단점을 모두 극복)
- 단점
  - 작은 파일인 경우 공간이 낭비된다. (실제로 많은 파일들의 크기가 작다.)
  - 너무 큰 파일인 경우 하나의 블록으로 인덱스를 모두 저장할 수 없다.
  - 해결 방안
    - linked scheme
      - 인덱스 블록의 마지막 위치가 또 다른 인덱스 블록을 가리키게 한다.
    - multi-level index
      - 인덱스 블록 내의 값들이 각각 인덱스 블록을 가리킨다.
      - (2단계 페이징 테이블과 유사)

