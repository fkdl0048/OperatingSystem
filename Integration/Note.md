# OperatingSystem Note

## 1장. 서론

운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 사이의 **중개자 역할**을 한다.  

운영체제의 목적은 편리하고 효율적으로 수행할 수 있는 **환경을 제공**하는 것이다.  

운영체제는 하드웨어를 관리하는 **소프트웨어**이다.  

### 운영체제가 하는 일  

컴퓨터 시스템은 대개 4가지 구성요소로 구분할 수 있다.  

* 하드웨어
* 운영체제
* 응용 프로그램
* 사용자

#### 하드웨어

하드웨어는 중앙 처리 장치(cpu), 메모리 및 입출력(I/O) 장치로 구성되어 기본 계산용 자원을 제공한다.  

#### 응용 프로그램

응용 프로그램은 워드 프로세서, 스프레드 시트, 컴파일러, 웹브라우저 등 사용자의 계산 문제를 해결하기 위해 이들 자원이 어떻게 사용될지 정의한다.  

*사용자 정의 포함*

#### 운영체제

운영체제는 다양한 사용자를 위해 다양한 응용 프로그램 간의 **하드웨어 사용을 제어하고 조정**한다.

#### 사용자 관점

컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.  

개인용 PC의 경우 시스템은 한 사용자가 **자원을 독접적하도록 설계**되었으며 목표는 사용자가 수행하는 작업을 최대화 하는 것이다.  

이 경우 운영체제는 **사용의 용이성**을 위해 설계되어 성능을 약간 신경쓰고, 자원이 어떻게 공유되는지 **자원의 이용**에는 전혀 신경쓰지 않는다.  

#### 시스템 관점

컴퓨터 관점에서 운영체제는 하드웨어와 가장 밀접하게 연괸된 프로그램으로 운영체제를 **자원 할당자**로 볼 수 있다.  

### 운영체제 정의  

일반적인 정의는 존재하지 않는다.  

또한 운영체제에 포함되는 요소에 보편적인 정의는 없다.  

운영체제는 컴퓨터에서 항상 실행되는 **프로그램(커널)**과 운영체제와 관련되어 있지만 반드시 커널의 일부일 필요는 없는 **시스템 프로그램**과 시스템 작동과 관련되지 않은 모든 프로그램을 포함하는 **응용 프로그램**이다.

### 컴퓨터 시스템의 구성

컴퓨터 시스템은 하나 이상의 CPU와 구성요소와 공유 메모리 사이의 액세스를 제공하는 버스를 통해 여러가지 장치 컨트롤러로 구성된다.  

일반적으로 운영체제에는 각 장치 컨트롤러마다 장치 드라이버가 있다.  

이 장치 드라이버는 장치 컨트롤러의 작동을 알고 있고 나머지 운영체제의 장치에 대한 일관적인 인터페이스를 제공한다.

### 인터럽트

#### 예시

일반적인 컴퓨터 작업을 생각한다면 입출력 작업을 시작하기 위해 **장치 드라이버**는 **장치 컨트롤러의 적절한 레지스터에 값을 적재**한다.  

그런 다음 장치 컨트롤러는 이러한 레지스터의 내용을 검사하여 수행할 작업(키보드에서 문자 읽기)을 결정한다.  

컨트롤러는 장치에서 로컬 버퍼로 데이터 전송을 시작한다.  

데이터 전송이 완료되면 장치 컨트롤러는 장치 드라이버에게 작업이 완료되었을 알린다.  

그런 다음 장치 드라이버는 읽기 요청이면 데이터 또는 데이터에 대한 포인터를 반환하며 운영체제의 다른 부분에 제어를 넘긴다.  

다른 작업의 경우 장치 드라이버는 "쓰기 완료", "장치 사용중"과 같은 정보를 반환한다.  

컨트롤러는 장치 드라이버에게 **인터럽트**를 통해서 작업이 완룓되었음을 알린다.

#### 정리

하드웨어는 어느 순간이든 시스템 버스를 통해 **CPU에 신호를 보내 인터럽트를 발생**시킬 수 있다.  

인터럽트는 다른 목적으로도 사용되며 운영체제와 하드웨어의 **상호작용 방식의 핵심** 부분이다.  

인터럽트 동작 방식은 책의 두가지 그림을 참고 1.3, 1.4

### 저장장치 구조

CPU는 메모리에서만 명령을 적재할 수 있으므로 실행하려면 **프로그램이 메모리에 적재**해야 한다.  

대부분의 프로그램은 메인 메모리 RAM이라 불리는 재기록 가능한 메모리에서 가져온디.  

컴퓨터는 다른 형태의 메모리도 사용한다.  

전원을 켜고 가장 먼저 실행되는 프로그램은 **부트스트랩 프로그램**이며 운영체제를 적재한다.  

RAM은 **휘발성**이므로 부트스트랩 프로그램을 유지하는 용도로 사용될 수 없다.

대신 이 목적과 다른 목적으로 컴퓨터는 전기적으로 소거 가능한 프로그램 가능 읽기 전용 메모리 EEPROM 및 기타 형태의 펌웨어를 사용한다.  

대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 보조저장장치를 제공한다.  

*하드디스크*  

대부분의 **프로그램은 메모리에 적재될 때까지 보조저장장치에 저장**된다.  

1.6 그림의 계층 참고

### 입출력 구조

운영체제 코드의 상당 부분은 시스템의 안정성과 성능에 대한 중요성과 장치의 다양한 특성으로 인해 I/O관리에 할애된다.  

### 컴퓨터 시스템 구조

* CPU: 명령을 실행하는 하드웨어
* 프로세서: 하나 이상의 CPU를 포함하는 물리적 칩
* 코어: CPU의 기본 계산 단위
* 다중 코어: 동일한 CPU에 여러 컴퓨팅 코어를 포함함
* 다중 처리기: 여러 프로세서를 포함함
* 프로세스: 실행 중인 프로그램

#### 단일 처리기 시스템  

단일 처리기 시스템은 하나의 CPU와 메모리, 입출력 장치로 구성된다.

#### 다중 처리기 시스템

다중 처리기 시스템은 하나 이상의 CPU와 메모리, 입출력 장치로 구성된다.

### 운영체제의 작동  

실행할 프로세스, 서비스할 I/O 장치 및 응답할 사용자가 없는 경우 운영체제는 조용히 앉아서 기다린다.  

이벤트는 거의 항상 인터럽트를 발생시켜 신호를 보낸다.  

또 다른 형태의 인터럽트는 **트랩**(0으로 나누거나..)또는 사용자 프로그램의 특정 요청 때문에 발생하는 소프트웨어 생성 인터럽트이다.  

이 특정 요청은 **시스템 콜**이라는 특수 연산을 실행하여 요청되고 운영체제가 제공하는 서비스가 수행될 것을 요구한다.  

### 다중 프로그래밍 다중 태스킹

다중 프로그래밍은 CPU가 항상 한 개는 실행할 수 있도록 프로그램을 구성하여 CPU 이용률을 높이고 사용자 만족도를 높인다.  

다중 프로그램 시스템에서 실행 중인 프로그램을 프로세스라고 한다.

운영체제는 **여러 프로세스를 동시에 메모리에 유지**한다.  

운영체제는 이러한 프로세스 중 하나를 선택하여 실행하기 시작한다.  

결국 프로세스는 I/O작업과 같은 일부 작업이 완료되기를 기다려야 할 수 있다.  

다중 프로그램 시스템에서 운영체제는 단순히 다른 프로세스로 **전환**하여 실행한다.  

해당 프로세스가 대기해야 하는 경우 CPU는 다른 프로세스로 전환한다.  

결국 첫 번째 프로세스는 대기를 마치고 CPU를 다시 돌려받는다.  

수업 중에 나온 볼펜 예제..  

다중 태스킹은 다중 프로그래밍의 논리적 확장이다.  

다중 태스킹 시스템에서 CPU는 여러 프로세스를 전환하며 프로세스를 실행하지만 전환이 자주 발생하여 사용자에게 빠른 응답 시간을 제공한다.

출력이 사용자를 위해 디스플레이되고, 입력은 사용자 키보드, 마우스 또는 터치스크린으로부터 들어온다.  

이러한 대화식 입출력은 전형적으로 사람의 속도로 수행되므로, 사람에게 1초에 7문자는 빠르지만 컴퓨터에겐 아주 느린 것이다.  

### 이중 모드와 다중모드 운용  

시스템을 올바르게 실행하려면 운영체제 코드 실행과 사용자 정의 코드 실행을 구분할 수 있어야 한다.  

즉, 사용자 모드와 커널 모드를 필요로 한다.  

모드 비트라고 하는 하나의 비트가 현재 모드를 나타내기 위해 컴퓨터 하드웨어에 추가되었다.  

0과 1로 구분하며 1은 사용자 모드, 0은 커널 모드를 나타낸다.

시스템콜이나 인터럽트가 발생하면 하드웨어는 사용자 모드를 커널모드로 변경한다.  

일부 악영향을 끼칠 수 있는 명령을 특권명령이라고 하며 하드웨어는 특권명령이 커널 모드에서만 실행되도록 한다.  

만약 사용자 모드에서 실행된다면 운영체제로 트랩을 건다.  

### 타이머  

우리는 운영체제가 CPU에 대한 제어를 유지할 수 있도록 보장해야 한다.

사용자 프로그램이 무한루프에 빠지거나 호출에 실패하여 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지해야 한다.  

이러한 문제를 해결하기 위해 운영체제는 **타이머**를 사용한다.  

### 자원 관리

운영체제는 자원 관리자이다.  

시스템의 CPU, 메모리 공간, 파일 저장 공간 및 I/O 장치는 운영체제가 관리해야 하는 자원에 속한다.

#### 프로세스 관리

프로그램은 CPU에 의해 명령이 실행되지 않으면 아무것도 할 수 없다.  

실행중인 프로그램은 프로세스이다.  

프로세스는 자기 일을 수행하기 위해 여러 자원을 필요로 한다.  

*CPU 시간, 메모리, 파일, 입출력 장치 등등*  

이러한 자원은 보통 실행되는 동안 할당된다.  

프로세스가 생성될 때 획득하는 여러 가지 물리적 논리적 자원 외에, 여러 초기화 데이터도 아울러 전달될 수 있다.  

프로그램은 프로세스가 아니다.  

하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 수동적 개체이지만 프로세스는 다음 수행할 명령을 지정하는 프로그램 카운터를 가진 능동적인 개체이다.  

한 프로세스의 수행은 반드시 순차적이어야 한다.  

CPU는 그 프로세스가 끝날 때까지 그 프로세스의 명령들을 차례대로 수행한다.  

한 프로세스는 한 시스템 내의 작업의 단위이다.  

이러한 시스템은 프로세스의 집합으로 구성되는데, 프로세스 중 일부는 운영체제 프로세스들이며, 나머지는 사용자 프로세스들이다.  

이러한 프로세스는 단일 CPU 코어에서 멀티플렉싱하거나 여러 CPU 코어에서 병렬로 실핼할 수 있다.  

운영체제는 프로세스 관리와 연관해 다음과 같은 활동에 책임을 진다.  

* 사용자 프로레스와 시스템 프로세스의 생성과 제거
* CPU에 프로세스와 스레드 스케줄하기
* 프로세스의 일시 중지와 재수행
* 프로세스 동기화를 위한 기법 제공
* 프로세스 통신을 위한 기법 제공

#### 메모리 관리

메모리는 현대 컴퓨터에서 매우 중요한 역할을 하며 대용량 배열로써, 각 바이트는 자신의 주소를 가진다.  

CPU가 명령을 수행하기 위해선 우선 메인 메모리에 있어야 한다.  

프로그램이 실행되기 위해선 반드시 절대 주소로 매핑되고 메모리에 적재되어야 한다.  

프로그램을 수행하면서, 이러한 절대 주소를 생성하고 메모리의 프로그램 명령어와 데이터에 접근한다.  

결국 프로그램이 종료되고, 프로그램이 차지하던 메모리 공간은 가용공간으로 선언되고, 다음 프로그램이 적재되어 수행될 수 있다.  

운영체제는 메모리 관리를 위해 다음과 같은 일을 담당한다.  

* 메모리의 어느 부분이 현재 사용되고 있으며 어느 프로세스에 의해 사용되고 있는지 추적
* 필요에 따라 메모리 공간을 할당하고 회수
* 어떤 프로세스들을 메모리에 적재하고 제거할 것인지 결정

#### 파일 시스템 관리

컴퓨터 시스템의 편리한 사용을 위해 운영체제는 정보 저장장치에 대한 균일한 논리적 관점을 제공한다.  

운영체제는 저장장치의 물리적 특성을 추상화하여 논리적 저장 단위인 파일을 저장한다.  

운영체제는 파일을 물리적 매체로 매핑하여, 저장장치를 통해 이들 파일에 접근한다.  

운영체제는 파일 관리를 위해 다음과 같은 일을 담당한다.

* 파일의 생성 및 제거
* 디렉터리 생성 및 제거
* 파일과 디렉터리를 조작하기 위한 프리미티브의 제공
* 파일을 보조저장장치로 매핑
* 안정적인 저장 매체에 파일을 백업

#### 대용량 저장장치 관리

컴퓨터 시스템은 메인 메모리를 백업하기 위해 보조저장장치를 제공해야 한다.  

운영체제는 보조저장장치를 관리와 관련하여 다음 활동을 담당한다.

* 마운팅과 언마운팅
* 사용 가능 공간의 관리
* 저장장소 할당
* 디스크 스케줄링
* 저장장치 분할
* 보호

#### 캐시 관리

캐싱은 컴퓨터 시스템의 중요한 원리이다.  

정보는 통상 어떤 저장장치에 보관된다.  

정보가 사용됨에 따라, 더 빠른 장치인 캐시에 일시적으로 복사된다.  

그러므로 우리는 특정 정보가 필요할 때 캐시에 그 정보가 있는지 먼저 조사한다.  

있다면 캐시를 사용하지만 없다면 메인메모리에 접근하여 가져와 사용될 확률이 높다는 가정하여 캐시에 넣는다.  

CPU 내부의 프로그램 가능한 레지스터들은 메인 메모리를 위한 고속의 캐시로 볼 수 있다.  

전적으로 하드웨어로 구현된 캐시도 있다.  

시스템은 대부분 다음에 수행될 것으로 예상되는 명령을 넣어 두는 명령 캐시를 갖고 있다.  

없다면 CPU는 메모리로부터 다음 명령을 인출해올 때 까지 몇 사이클을 기다려야 한다.  

유사한 이유로 시스템 대부분은 하나 이상의 고속 데이터 캐시를 가지고 있다.  

이러한 캐시는 운영체제로 제어가 불가능하다.  

* 캐시의 일관성 문제: 다중 처리기 환경에서 A의 복사본이 여러 캐시에 존재할 수 있다. 여러개의 CPU가 동시에 실행될 수 있으므로, 한 캐시에 있는 A값이 갱신될 경우 A가 존재하는 모든 캐시가 즉각적으로 변경되어야 한다..  

*일반적으로 하드웨어적 문제*  

#### 입출력 시스템 관리

운영체제의 목적 중의 하나는 사용자에게 특정 하드웨어 장치의 특성을 숨기는 것이다.  

입출력 장치의 특성은 입출력 서브시스템에 의해 운영체제 자체의 대부분으로부터 숨겨져 있다.  

입출력 시스템은 다음과 같이 구성되어 있다.

* 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성요소
* 일반적인 장치 드라이버 인터페이스
* 특정 하드웨어 장치들을 위한 드라이버

### 보안과 보호

만일 컴퓨터 시스템이 다수의 사용자를 가지며 다수 프로세스의 병행 수행을 허용한다면, 데이터에 대한 접근은 반드시 규제되어야 한다.  

이를 위해 파일, 메모리 세그먼트, CPU 및 다른 자원들에 대해 운영체제로부터 적절한 허가를 획득한 프로세스만이 작업할 수 있도록 보장하는 기법이 필요하다.

예를 들어 메모리 주소지정 하드웨어는 프로세스가 자신의 주소 영역에서만 실행될 수 있도록 보장한다.

보호란, 컴퓨터 시스템이 정의한 자원에 대해 프로그램, 프로세스, 또는 사용자를 제어하는 기법이다.  

### 가상화

가상화는 단일 컴퓨터의 하드웨어를 여러 가지 실행 환경으로 추상화하여 개발 환경이 자신만의 컴퓨터에서 실행되고 있다는 환상을 만들어주는 기술이다.

### 분산 시스템

분산 시스템은 물리적으로 떨어져 있는 이기종 컴퓨터들의 집합이다.  

### 커널 자료구조

운영체제 구현의 중심이 되는 주제, 즉 시스템에서 데이터가 구조화되는 방법을 다룬다.

#### 리스트 스택 및 큐

#### 트리

#### 해시함수와 맵

#### 비트맵

### 계산 환경

스킵

## 2장 운영체제 구조

### 운영체제 서비스  

운영체제는 프로그램 실행 환경을 제공한다.  

운영체제는 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공한다.

* 사용자 인터페이스  

거의 모든 운영체제는 사용자 인터페이스를 제공한다.  

일반적으로 GUI환경이나 CLI환경을 제공한다.

* 프로그램 수행

시스템은 메모리에 적재해 실행할 수 있어야 한다.  

프로그램은 정상적이든, 비정상적이든 실행을 끝낼 수 있어야 한다.  

* 입출력 연산

수행중인 프로그램은 입출력을 요구할 수 있다.  

이러한 입출력에는 파일 혹은 입출력 장치가 연관될 수 있다.  

* 파일 시스템 조작

* 통신

* 오류 탐지

반대로 사용자에게 도움을 주는게 아닌 시스템 자체의 효율성을 높이기 위한 운영체제의 기능도 있다.

* 자원 할당  

다수의 프로세스나 다수의 작업이 동시에 실행될 때 그들 각각에 자원을 할당해줘여 한다.  

* 기록 작성  

어떤 프로그램이 어떤 종류의 컴퓨터 자원을 얼마나 많이 사용하는지 추적할 수 있길 원한다.  

* 보호와 보안

### 사용자와 운영체제 인터페이스

사용자와 운영체제가 접촉하기 위해선 CLI방식과 GUI방식으로 구분된다.

#### 명령 인터프리터  

셸을 통해 CLI환경에서 접촉한다.

#### GUI기반  

#### 터치스크린 인터페이스

### 시스템 콜  

시스템 콜은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.  

특정 저수준 작업은 어셈블리 명령을 사용하여 작성되어야 하더라도 이러한 호출은 일반적으로 C 라이브러리 함수로 제공된다.

ex) fork(), read(), write(), open(), close(), exec(), wait(), exit()

#### 응용 프로그래밍 인터페이스  

대부분의 개발자는 응용 프로그래밍 인터페이스 API에 따라 프로그램을 설계한다.  

시스템 콜 인터페이스 API함수의 호출을 가로채어 필요한 운영체제 시스템 콜을 부른다.  

운영체제에 메개변수를 전달하기 위해서 세 가지 일반적인 방법을 사용한다.  

가장 간단한 방법은 매개변수를 레지스터 내에 전달하는 것이다.  

그러나 어떤 경우에는 레지스터보다 더 많은 매개변수가 있을 수 있다.  

이러한 경우 매개변수는 메모리 내의 블록이나 테이블에 저장되고, 블록의 주소가 레지스터 내에 매개변수로 전달된다.  

#### 시스템 콜의 유형

시스템 콜은 다섯 가지의 중요한 범주, 즉 프로세스 제어, 파일 조작, 장치 조작, 장버 유지 보수, 통신과 보호등으로 엮을 수 있다.  

* 프로세스 제어
  * 끝내기, 중지
  * 적재, 수행
  * 프로세스 생성, 종료
  * 속성 획득, 속성 설정
  * 시간을 기다림
  * 이벤트를 기다림, 이벤트를 알림
  * 메모리 할당 및 자유화
* 파일 조작
  * 파일 생성, 삭제
  * 열기, 닫기
  * 읽기, 쓰기, 위치 변경
  * 파일 속성 획득 및 설정
* 창치 관리
  * 장치를 요구, 장치를 방출
  * 읽기, 쓰기, 위치 변경
  * 창치 속성 획득, 창치 속성 설정
  * 장치 논리적 부착 또는 분리
* 정보 유지
  * 시간과 날짜의 설정을 획득
  * 시스템 데이터의 설정과 획득
  * 프로세스, 파일, 장치 속성의 획득
  * 프로세스, 파일, 장치 속성의 설정
* 통신
  * 통신 연결의 생성, 제거
  * 메세지의 송신, 수신
  * 상태 정보 전달
  * 원격 장치의 부착 및 분리
* 보호
  * get file Permission
  * set file Permission

#### 프로세스 제어

실행중인 프로그램은 정상적으로 또는 비정상적으로 멈출 수 있어야 한다.  

트랩으로 인해 오류 메세지 생성 -> 큰 CORE파일 생성

### 시스템 서비스  

현대 시스템의 또 다른 면은 시스템 서비스의 집합체이다.  

시스템 서비스는, 시스템 유틸리티로도 알려진, 프로그램 개발과 실행을 위해 더 편리한 환경을 제공한다.  

그들 중 몇몇은 단순히 시스템 콜에 대한 사용자 인터페이스이며, 반면에 나머지는 훨씬 더 복잡하다.

* 파일 관리: 이들 프로그램은 파일과 디렉터리를 생성, 삭제, 복사, 개명, 인쇄, 열거하고, 그리고 일반적으로 조작한다.  

* 상태 정보: 어떤 프로그럄은 단순히 시스템에게 날짜, 시간, 사용 가능한 메모리와 디스크 공간의 양, 사용자 수, 혹은 이와 비슷한 상태 정보를 묻는다.  

* 파일 변경: 디스크나 다른 저장 장치에 저장된 파일의 내용을 생성하고 변경하기 위해 다수 문장 편집기를 사용할 수 있다.  

* 프로그래밍 언어 지원: 일반적인 프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 해석기가 운영체제와 함계 사용자에게 제공된다.  

* 프로그램 적재와 수행: 일단 프로그램이 어셈블리되거나 컴파일이 된 후 그것이 수행되려면 반드시 메모리에 적재되어야 한다.  

* 통신: 이들 프로그램은 프로세스, 사용자, 그리고 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법을 제공한다.

* 백그라운드 서비스: 모든 범용 시스템은 부트할 때 특정 시스템 프로그램을 시작시킬 수 있는 방법을 가지고 있다.


생략...  

## 3장 프로세스

### 프로세스 개념  

초창기 컴퓨터는 작업을 실행하는 일괄처리 시스템이었고, 사용자 프로그램 또는 테스크를 실행하는 시분할 시스템이 뒤를 이었다.

#### 프로세스  

비공식적으로 프로세스는 실행 중인 프로그램이다.  

프로세스는 현재 활동의 상태는 프로그램 카운터값과 프로세서 리지스터의 내용으로 나타낸다.  

* 텍스트 섹션: 실행 코드
* 데이터 섹션: 전역 변수
* 힙 섹션: 프로그램이 실행 중에 동적으로 할당되는 메모리
* 스택 섹션: 함수를 호출할 때 임시 데이터 저장장소

텍스트 및 데이터 섹션의 크기는 고정되기 때문에 프로그램 실행시간 동안 크기가 변하지 않는다.  

그러나 스택과 힙은 프로그램 실행 중 동적으로 크기가 변한다.  

프로세스 상태 다이어그램 참고  

#### 프로세스 상태  

프로세스는 실행되면서 그 상태가 변한다.  

프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라서 정의된다.  

프로세스는 다음 상태 중 하나에 있게 된다.

* 새로운: 프로세스가 생성 중
* 실행: 명령어들이 실행되고 있다.
* 대기: 프로세스가 어떤 이벤트가 일어나길 기다린다.
* 준비: 프로세스 처리기에 할당되기를 기다린다.
* 종료: 프로세스의 실행이 종료되었다.

#### 프로세스 제어 블록

각 프로세스는 운영체제에서 프로세스 제어 블록에 의해 표현된다.  

* 프로세스 상태: 위에서 다룬 상태
* 프로그램 카운터: 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.
* CPU 레지스터들: CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가진다.

누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터들과 상태 레지스터들과 상태 코드정보가 포함된다.  

프로그램 카운터와 이 상태 정보는, 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서 인터럽트 발생 시 저장되어야 한다.

* CPU 스케줄링 정보: 프로세스의 우선순위, 스케줄 큐에 대한 포인터, 그리고 다른 스케줄링 정보가 포함된다.
* 메모리 관리 정보: 프로세스가 사용하는 메모리의 주소 범위, 페이지 테이블에 대한 포인터, 그리고 다른 메모리 관리 정보가 포함된다.
* 회계 정보: 사용된 CPU 시간, 시간 제한, 계정 번호, 그리고 다른 회계 정보가 포함된다.
* 입출력 상태 정보: 프로세스가 사용하는 입출력 장치들에 대한 포인터, 그리고 다른 입출력 상태 정보가 포함된다.

요약하자면 프로세스 제어 블록은 약간의 회계 데이터와 함께 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소의 역할을 한다.

#### 스레드


## 시험

응용 프로그램, 커널, 시스템 프로그램의 차이점 하는일

운영체제의 프로세스 개년

그림 위주로

ch01 14~17, 19~24
ch02 16~19, 39~41
ch03 0~12

여기서 주관식 문제 8문제 그림에 대한 명확한 이해 -> 이 부분 위주로 공부하면댐

